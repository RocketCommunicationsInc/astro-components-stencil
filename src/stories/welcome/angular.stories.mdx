import { Meta } from '@storybook/addon-docs/blocks'

<Meta title="Astro UXDS/Welcome/Angular" />

# Angular

## Installation

### Via NPM

`npm i @astrouxds/astro-web-components`


## Integration of astro-web-components into an angular application.

1. Include `CUSTOM_ELEMENTS_SCHEMA` in any module that uses an astro-web-component.

```js
import { BrowserModule } from '@angular/platform-browser'
import { CUSTOM_ELEMENTS_SCHEMA, NgModule } from '@angular/core'
import { FormsModule } from '@angular/forms'

import { AppComponent } from './app.component'

@NgModule({
    declarations: [AppComponent],
    imports: [BrowserModule, FormsModule],
    bootstrap: [AppComponent],
    schemas: [CUSTOM_ELEMENTS_SCHEMA],
})
export class AppModule {}
```

2. Define your Custom Elements in `main.ts`

```js
import { enableProdMode } from '@angular/core'
import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'

import { AppModule } from './app/app.module'
import { environment } from './environments/environment'

import { defineCustomElements } from '@astrouxds/astro-web-components/loader'

if (environment.production) {
    enableProdMode()
}

platformBrowserDynamic()
    .bootstrapModule(AppModule)
    .catch((err) => console.log(err))
defineCustomElements()
```

3. Add global components styling to `angular.json`.

```json
 "architect": {
    "build": {
      "builder": "@angular-devkit/build-angular:browser",
      "options": {
        "styles": [
          "./node_modules/@astrouxds/astro-web-components/dist/astro-web-components/astro-web-components.css",
        ],
      },
    },
```

4. (Optional) In order to change global astro-web-compoennts styling from default `dark-theme` to `light-theme`.
Add corresponding theme class (`light-theme`) to desire parent container.
Usually the easiest way is to add it onto `<body>` tag of the `index.html` file.

## Setting Props

### Basic Data

For basic primitive types like `string`, `boolean`, `number`, set the attribute on the element:

```html
<rux-button size="large"></rux-button>
```

### Dynamic Data

Alternatively props can be set dynamically via property binding. This option comes in useful in `*ngFor` loops when
data is not instantly available.

```js
const buttons = [
    { size: 'small', type: 'button', text: 'First'},
    { size: 'medium', type: 'button', text: 'Second'},
    { size: 'large', type: 'submit', text: 'Submit'},
];
```

```html
<div *ngFor="let button of buttons">
    <rux-button [size]="button.size" [type]="button.type">{{ button.text }}</rux-button>
</div>
```

## Using Slots

Slots give you full control over the contents of a component. Some components may have multiple slots.

> Web Component Concept:
> Slotted content lives outside of the shadow DOM and as a result, you are free to style them however you want.

```html
  <rux-global-status-bar>
    <rux-icon slot="left-side" icon="apps"></rux-icon>
    <div slot="app-meta">
      <h1>Hello World</h1>
    </div>
  </rux-global-status-bar>
```

## Listening To Events

```html
  <rux-input name="myInput" (rux-change)="onInputChange($event)">
```

In TypeScript, accessing the events target value requires some type assertion.

```js

onInputChange(e: CustomEvent<HTMLRuxInputFieldElement>){
  const target = e.target as HTMLInputElement;
  console.log(`Here is e.target.value: ${target.value}`)
}
```

## Methods

Some components offer public methods that can be executed. These methods are async and can be executed by setting a ViewChild decorator on the element.
The Angular docs for setting and using `ViewChaild` decorator can be found [here](https://angular.io/api/core/ViewChild).

```html
      <rux-pop-up-menu #myPopUpMenu id="pop-up-menu">
        <rux-menu-item value="1">Item 1</rux-menu-item>
        <rux-menu-item-divider></rux-menu-item-divider>
        <rux-menu-item value="2">Item 2</rux-menu-item>
    </rux-pop-up-menu>
```

```js
import { Component } from '@angular/core';

@Component({
  selector: 'app-example',
  templateUrl: './example.component.html',
})
export class ExampleComponent {
    @ViewChild('myPopUpMenu') myTestPopUpMenu: ElementRef<HTMLRuxPopUpMenuElement>;
    async onAction() {
        await this.myTestPopUpMenu.nativeElement.isOpen();
    }
}
```


## Integration of two-way data binding with form compoennts.

To get web component to work with `ngModel` and `formControlName` directives `ngDefaultControl` must be set on the form element.
It will set the default ControlValueAccessor for writing a value and listening to changes on input elements.

```html
  <rux-input name="myInput" ngDefaultControl [(ngModel)]="myInputVar"></rux-input>
```

Alternativally ControlValueAccessor directive may be created to omit the use of `ngDefaultControl`.
ControlValueAccessor: Defines an interface that acts as a bridge between the Angular forms API and a native element in the DOM. Implement this interface to create a custom form control directive that integrates with Angular forms.

```js
import { Directive, ElementRef, forwardRef, HostListener } from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';

@Directive({
  // directive taps directly into web component and changes its behavior by utilizing
  // the same tag name as the original web component
  selector: 'rux-input',
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => RuxInputDirective),
      multi: true,
    },
  ],
})
export class RuxInputDirective {
  onChange: any = () => {};
  onTouched: any = () => {};

  private _value: boolean;

  get value() {
    return this._value;
  }

  set value(val) {
    if (val !== this._value) {
      this._value = val;
      this.onChange(this._value);
      this.onTouched();
    }
  }

  constructor(private elementRef: ElementRef) {}

  @HostListener('rux-input', ['$event.detail'])
  listenForValueChange(value) {
    this.value = value;
  }

  writeValue(value) {
    if (value) {
      this.value = value;
    }
  }

  registerOnChange(fn) {
    this.onChange = fn;
  }

  registerOnTouched(fn) {
    this.onTouched = fn;
  }
}
```
