import { Meta } from '@storybook/addon-docs/blocks'

<Meta title="Astro UXDS/Welcome/Vue 3" />

# Vue 3 Integration

Out of the box, Vue has [nearly flawless support for Web Components](https://v3.vuejs.org/guide/web-components.html). The only limitation is that **v-model is not supported.**


### Via NPM

`npm i @astrouxds/astro-web-components`


You have two options for importing Astro Web Components: Lazy Loading and Cherry Picking.

#### Lazy Loading

Astro Web Components make use of Stencil's automatic lazy loader which only loads components that are actually used on the page.

```js
// main.js
import Vue from 'vue'
import App from './App.vue'

Vue.config.productionTip = false

// Import Astro's base styles
import '@astrouxds/astro-web-components/dist/astro-web-components/astro-web-components.css'

import { defineCustomElements } from '@astrouxds/astro-web-components/dist/custom-elements';
defineCustomElements();

new Vue({
  render: h => h(App),
}).$mount('#app')

```

#### Cherry Picking

If you need more control over your bundle size, you can also import and register individual components.
Cherry picking components will result in a much smaller overall bundle size; however, you will need to manually register any component dependencies.
This will be listed for each component in their documentation.

```js
// main.js
import Vue from 'vue'
import App from './App.vue'

Vue.config.productionTip = false

// Import Astro's base styles
import '@astrouxds/astro-web-components/dist/astro-web-components/astro-web-components.css'


// Import Button
import { RuxButton } from '@astrouxds/astro-web-components/dist/components/rux-button'

// Register Button
customElements.define('rux-button', RuxButton)

new Vue({
  render: h => h(App),
}).$mount('#app')


```


Import [Roboto](https://fonts.google.com/specimen/Roboto) in your index.html. We recommend using Google's CDN for ease of use but you can also install it locally.

```html
<link rel="preconnect" href="https://fonts.gstatic.com" />
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400&family=Roboto:wght@200;300;400;500;600;800&display=swap" rel="stylesheet"/>
```

### Skipping Component Resolution

By default, Vue will attempt to resolve a non-native HTML tag as a registered Vue component before falling back to rendering it as a custom element.
To let Vue know that certain elements should be treated as custom elements and skip component resolution, we can specify the compilerOptions.isCustomElement option.

<rux-tabs id="tab-set-id-1" small style={{height:'auto'}}>
  <rux-tab id="tab-id-1">Vite</rux-tab>
  <rux-tab id="tab-id-2">Webpack</rux-tab>
</rux-tabs>

<rux-tab-panels aria-labelledby="tab-set-id-1">
  <rux-tab-panel aria-labelledby="tab-id-1">

```js
// vite.config.js
import vue from '@vitejs/plugin-vue'

export default {
  plugins: [
    vue({
      template: {
        compilerOptions: {
          // treat all tags with a dash as custom elements
          isCustomElement: tag => tag.includes('-')
        }
      }
    })
  ]
}
```
  </rux-tab-panel>
  <rux-tab-panel aria-labelledby="tab-id-2">

```js
// vue.config.js
module.exports = {
  chainWebpack: config => {
    config.module
      .rule('vue')
      .use('vue-loader')
      .tap(options => ({
        ...options,
        compilerOptions: {
          // treat any tag that starts with ion- as custom elements
          isCustomElement: tag => tag.startsWith('ion-')
        }
      }))
  }
}
```
  </rux-tab-panel>
</rux-tab-panels>


## Setting Props

### Basic Data

For basic primitive types like `string`, `boolean`, `number`, set the attribute on the element:

```js
<rux-button size="large"></rux-button>
```

### Complex Data
For non primitives like `array` or `object`, make use of Vue's .prop modifier:
```js
<template>
  <rux-segmented-button :data.prop="data"></rux-segmented-button>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  setup() {
    const data = [
        { label: 'First item' },
        { label: 'Second item' },
        { label: 'Third item' },
    ]
    return {
      data
    }
  }
})
</script>
```
## Using Slots

Slots give you full control over the contents of a component. Some components may have multiple slots.

> Web Component Concept:
> Slotted content lives outside of the shadow DOM and as a result, you are free to style them however you want.

Vue's slots were inspired by the Web Component spec so they should look very familiar:

```html
<rux-global-status-bar>
  <rux-icon slot="left-side" icon="apps"></rux-icon>
  <div slot="app-meta">
    <h1>Hello World</h1>
  </div>
</rux-global-status-bar>
```

## Listening to Events

Astro Components emit their own custom events, prefixed with `rux`. You will likely use these to sync state between your Vue components and the Astro Web Components.

```js
<template>
  <rux-input-field @rux-input="handleInput"></rux-input-field>
</template>

<script lang="ts">
import { defineComponent } from 'vue'

export default defineComponent({
  setup() {
    const handleInput = (event: Event) => {
      console.log('heard event', event)
    }
    return {
      handleInput
    }
  }
})
</script>
```

## Methods

Some components offer public methods that can be executed. These methods are async and can be executed by setting a ref on the element.

```js
<template>
  <rux-tree>
    <rux-tree-node ref="node">Hello</rux-tree-node>
    <rux-tree-node>World</rux-tree-node>
  </rux-tree>
  <rux-button @click="selectNode">Select Node</rux-button>
</template>

<script lang="ts">
import { defineComponent, ref } from "vue";

export default defineComponent({
  setup() {
    const node = ref<HTMLRuxTreeNodeElement | null>(null);
    const selectNode = () => {
      if (node && node.value) {
        node.value.setSelected(true);
      }
    };

    return {
      node,
      selectNode,
    };
  }
});
</script>
```

## Data Binding

One current limitation with Web Components in Vue is that **v-model is not supported** because Astro Components emit their own custom events.
Since `v-model` is just syntactic sugar for `:modelValue` and `@update:modelValue`, you just need to explicitly listen for `@rux-{event}`.

```js
<template>
  <rux-input-field :modelValue="firstName" @rux-input="firstName = $event.target.value"></rux-input-field>
    {{firstName}}
</template>

<script lang="ts">
import { defineComponent, ref } from "vue";

export default defineComponent({
  setup() {
    const firstName = ref('')

    return {
      firstName
    };
  }
});
</script>
```
